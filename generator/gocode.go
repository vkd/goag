package generator

import (
	"fmt"
	"io"
	"text/template"
)

type GoFile struct {
	DoNotEdit   bool
	PackageName string

	Imports []GoFileImport

	Body Render
}

//nolint:gci
var tmGoFile = template.Must(template.New("GoFile").Parse(`
{{- if .DoNotEdit}}// Code is generated by goag. DO NOT EDIT!
{{end -}}
package {{.PackageName}}

{{- if .Imports}}

import (
	{{- range $i, $imp := .Imports}}
	{{if $imp.Alias}}{{$imp.Alias}} {{end}}"{{$imp.Package}}"
	{{- end}}
)
{{- end}}

{{- if .Body}}

{{.Body.String}}
{{- end}}
`))

func (g GoFile) String() (string, error)  { return String(tmGoFile, g) }
func (g GoFile) Render(w io.Writer) error { return tmGoFile.Execute(w, g) }

type GoFileImport struct {
	Alias   string
	Package string
}

type GoTypeDef struct {
	Comment string
	Name    string
	Type    Render
}

func NewGoTypeDef(i SchemasItem) (zero GoTypeDef, _ error) {
	sr, err := NewSchemaRef(i.Schema)
	if err != nil {
		return zero, fmt.Errorf("new schema ref: %w", err)
	}
	return GoTypeDef{
		Name:    i.Name,
		Comment: i.Schema.Value.Description,
		Type:    sr,
	}, nil
}

func NewGoTypeDefs(si SchemasItems) ([]GoTypeDef, error) {
	out := make([]GoTypeDef, 0, len(si))
	for _, i := range si {
		td, err := NewGoTypeDef(i)
		if err != nil {
			return nil, err
		}
		out = append(out, td)
	}
	return out, nil
}

var tmGoTypeDef = template.Must(template.New("GoTypeDef").Parse(`
{{- if .Comment}}// {{.Name}} - {{.Comment}}
{{end -}}
type {{.Name}} {{.Type.String -}}
`))

func (g GoTypeDef) String() (string, error) { return String(tmGoTypeDef, g) }

type GoStruct struct {
	Fields []GoStructField
}

var tmGoStruct = template.Must(template.New("GoStruct").Parse(`
{{- if .Fields -}}
struct{
	{{- range $_, $f := .Fields}}
	{{$f.String -}}
	{{end}}
}
{{- else -}}
struct{}
{{- end}}`))

func (g GoStruct) String() (string, error) { return String(tmGoStruct, g) }

func (g GoStruct) Parser(from, to string, mkErr FuncNewError) (Render, error) {
	return StructParser{from, to, mkErr}, nil
}

type GoStructField struct {
	Name    string
	Comment string
	Type    Render
	Tags    []GoFieldTag
}

func NewGoStructField(i SchemasItem) (zero GoStructField, _ error) {
	sr, err := NewSchemaRef(i.Schema)
	if err != nil {
		return zero, fmt.Errorf("new schema ref: %w", err)
	}
	sf := GoStructField{
		Name: PublicFieldName(i.Name),
		Type: sr,
	}
	if sf.Name != i.Name {
		sf.Tags = append(sf.Tags, GoFieldTag{"json", i.Name})
	}
	return sf, nil
}

func NewGoStructFields(si SchemasItems) ([]GoStructField, error) {
	out := make([]GoStructField, 0, len(si))
	for _, i := range si {
		sf, err := NewGoStructField(i)
		if err != nil {
			return nil, err
		}
		out = append(out, sf)
	}
	return out, nil
}

var tmGoStructField = template.Must(template.New("GoStructField").Parse(`
{{- if .Comment}}// {{.Name}} - {{.Comment}}
{{end -}}
{{.Name}} {{.Type.String}}
{{- if .Tags}} ` + "`" + `
	{{- range $i, $t := .Tags}}
		{{- if $i}} {{end}}
		{{- $t.String}}
	{{- end}}` + "`" + `
{{- end -}}
`))

func (g GoStructField) String() (string, error) { return String(tmGoStructField, g) }

type GoFieldTag struct {
	Key   string
	Value string
}

var tmGoFieldTag = template.Must(template.New("GoFieldTag").Parse(`{{.Key}}:"{{.Value}}"`))

func (g GoFieldTag) String() (string, error) { return String(tmGoFieldTag, g) }

type GoType string

func (g GoType) String() (string, error) { return string(g), nil }

const (
	StringType GoType = "string"

	Int   GoType = "int"
	Int32 GoType = "int32"
	Int64 GoType = "int64"
	// Struct GoType = "struct"
	// Slice GoType = "slice"

	Float32 GoType = "float32"
	Float64 GoType = "float64"
)

func (g GoType) Parser(from, to string, mkErr FuncNewError) (Render, error) {
	switch g {
	case StringType:
		return AssignNew{from, to}, nil
	case Int:
		return ConvertToInt{from, to, mkErr}, nil
	case Int32:
		return ConvertToInt32{from, to, mkErr}, nil
	case Int64:
		return ConvertToInt64{from, to, mkErr}, nil
	case Float32:
		return ConvertToFloat32{from, to, mkErr}, nil
	case Float64:
		return ConvertToFloat64{from, to, mkErr}, nil
	}
	return nil, fmt.Errorf("unsupported GoType: %q", g)
}

type GoSlice struct {
	Items SchemaRender
}

var tmGoSlice = template.Must(template.New("GoSlice").Parse(`[]{{ .Items.String }}`))

func (s GoSlice) String() (string, error) { return String(tmGoSlice, s) }

func (s GoSlice) Parser(from, to string, mkErr FuncNewError) (Render, error) {
	switch t := s.Items.(type) {
	case GoType:
		switch t {
		case StringType:
			return Assign{from + "[0]", to}, nil
		}
	}
	panic("not implemented")
}

func (GoSlice) Optionable() {}

func (s GoSlice) StringsParser(from, to string, mkErr FuncNewError) (Render, error) {
	switch t := s.Items.(type) {
	case GoType:
		switch t {
		case StringType:
			return Assign{from, to}, nil
		}
	}
	return ConvertStrings{s.Items, from, to, mkErr}, nil
}

type GoMap struct {
	Key, Value SchemaRender
}

var tmGoMap = template.Must(template.New("GoMap").Parse(`map[{{ .Key.String }}]{{ .Value.String }}`))

func (s GoMap) String() (string, error) { return String(tmGoMap, s) }

func (s GoMap) Parser(from, to string, mkErr FuncNewError) (Render, error) {
	panic("not implemented")
}

func (GoMap) Optionable() {}

type ConvertStrings struct {
	ItemType SchemaRender
	From, To string
	MkErr    FuncNewError
}

var tmConvertStrings = template.Must(template.New("ConvertStrings").Parse(`
{{- .To}} = make([]{{.ItemType}}, len({{.From}}))
for i := range {{.From}} {
	{{.ItemRender (print .From "[i]") (print .To "[i]")}}
}`))

func (c ConvertStrings) ItemRender(from, toOrig string) (string, error) {
	to := "v1"
	r, err := c.ItemType.Parser(from, to, c.MkErr)
	if err != nil {
		return "", fmt.Errorf("item parser: %w", err)
	}
	r = Combine{r, Assign{to, toOrig}}
	return r.String()
}

func (c ConvertStrings) String() (string, error) { return String(tmConvertStrings, c) }
