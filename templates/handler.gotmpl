{{/* {{ template "do_not_edit" }} */}}

package {{.PackageName}}
{{- $basePath := $.BasePath }}

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"
	"strings"
)
{{ range $_, $h := .Handlers }}
{{- $name := $h.Name}}
{{- $handlerFuncName := print $name `HandlerFunc` }}
{{- $requestName := print $name `Request` }}
{{- $requesterName := print $name `Requester` }}
{{- $responderName := print $name `Responder` }}
{{- $writeResponseFuncName := print `write` $name `Response` }}
{{- $requestParamsName := print `request` $name `Params` }}
{{- $newParamsName := print `new` $name `Params` }}
{{- $needInvalidFn := or .Parameters.Queries .Parameters.Path .RequestBody}}
{{- /* --------------------------------- */}}
// ---------------------------------------------
// {{$name}} - {{$h.Summary}}
// ---------------------------------------------

{{if $h.Description}}// {{$handlerFuncName}} - {{$h.Description}}{{end}}
type {{$handlerFuncName}} func(r {{$requesterName}}) {{$responderName}}

func (f {{$handlerFuncName}}) Handle(r {{$requesterName}}) {{$responderName}} {
	return f(r)
}

func (f {{$handlerFuncName}}) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	f.Handle({{$requestParamsName}}{Request: r}).{{$writeResponseFuncName}}(w)
}

type {{$requesterName}} interface {
	Parse() ({{$requestName}}{{if $needInvalidFn}}, error{{end}})
}

type {{$requestParamsName}} struct {
	Request *http.Request
}

func (r {{$requestParamsName}}) Parse() ({{$requestName}}{{if $needInvalidFn}}, error{{end}}) {
	return {{$newParamsName}}(r.Request)
}

type {{$requestName}} struct {
	HTTPRequest *http.Request
	{{range $_, $q := .Parameters.Queries}}
	{{$q.Field.String}}
	{{- end}}
	{{- range $_, $p := .Parameters.Path}}
	{{$p.FieldName}} {{$p.Type.String}}
	{{- end}}
	{{- if .RequestBody}}

	Body {{.RequestBody.String}}
	{{- end}}
}

func {{$newParamsName}}(r *http.Request) (zero {{$requestName}}{{if $needInvalidFn}}, _ error{{end}}) {
	var params {{$requestName}}
	params.HTTPRequest = r

	{{if .Parameters.Queries}}
	{
		query := r.URL.Query()
		{{- range $_, $q := .Parameters.Queries}}
		{
			{{$q.Parser.String}}
		}
		{{- end}}
	}
	{{end}}

	{{if .Parameters.Path}}
	{
		p := r.URL.Path
		{{- if $basePath }}
		if !strings.HasPrefix(p, "{{$basePath}}") {
			return zero, fmt.Errorf("wrong path: expected '{{$basePath}}...'")
		}
		p = p[{{len $basePath }}:] // "{{$basePath}}"

		if !strings.HasPrefix(p, "/") {
			return zero, fmt.Errorf("wrong path: expected '{{$basePath}}/...'")
		}

		{{ end -}}
		{{- range $_, $p := .Parameters.PathParsers}}

		{{$p.String}}
		{{- end}}
	}
	{{end}}

	{{- if .RequestBody}}

	defer r.Body.Close()
	err := json.NewDecoder(r.Body).Decode(&params.Body)
	if err != nil {
		return zero, fmt.Errorf("decode request body: %w", err)
	}
	{{- end}}

	return params{{if $needInvalidFn}}, nil{{end}}
}

type {{$responderName}} interface {
	{{$writeResponseFuncName}}(w http.ResponseWriter)
}

{{ range $_, $r := .Responses }}
{{$r.String}}
{{ end }}

{{ end -}}

var LogError = func(err error) {
	log.Println(fmt.Sprintf("Error: %v", err))
}

func writeJSON(w io.Writer, v interface{}, name string) {
	err := json.NewEncoder(w).Encode(v)
	if err != nil {
		LogError(fmt.Errorf("write json response %q: %w", name, err))
	}
}

type ErrParseQueryParam struct {
	Name string
	Err  error
}

func (e ErrParseQueryParam) Error() string {
	return fmt.Sprintf("query parameter '%s': %e", e.Name, e.Err)
}

type ErrParsePathParam struct {
	Name string
	Err  error
}

func (e ErrParsePathParam) Error() string {
	return fmt.Sprintf("path parameter '%s': %e", e.Name, e.Err)
}
